javascript中的执行环境和作用域详解
---

- 执行环境(execution context)是js中最为重要的一个概念，执行环境定义了变量或者函数有权访问的其他数据，决定了他们各自的行为。
- 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
- 全局执行环境是最外围的一个执行环境，在web浏览器中，全局执行函数被认为是window对象，因此所有全局变量和函数都作为window对象的属性和方法创建的。
- 某个执行环境中所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。
- 全局执行环境直到应用程序退出也随之销毁(关闭网页和浏览器的时候)。(引自《javascript高级编程第四章73页》)。
- 书上说，当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。
- 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。
- 活动对象在一开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。
- 作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。
- 这样一直延续到全局执行环境；全局执行环境始终是作用域链中的最后一个对象。

这样太抽象对不对，好吧，来个例子解释下：

```javascript
function outer() {
  function inner() {
    var haha = 1;
  }
}
```

分析：haha 这个变量在inner这个执行环境中，inner这个函数在outer这个执行环境中，outer这个函数在window这个最大的执行环境中。
所以变量haha的作用域链为：inner-outer-window。
说到这里，不得不提一下作用域的问题了，作用域分为局部作用域和全局作用域。

有如下几种情况可归纳为全局作用域：

- ①最外层函数和在最外层函数外面定义的变量拥有全局作用域。
- ②所有末定义直接赋值的变量自动声明为拥有全局作用域。
-  ③所有window对象的属性拥有全局作用域。而局部作用域：是函数内部的作用域，一般只在固定的代码片段内可访问到，有时候也成为函数作用域。
- 这里引申一下变量的搜索机制：先搜索局部变量，如果没找到，往上一层查找，直到搜索全部变量，如果都没找到，返回undefined.
- 在每个执行环境中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。
- 延长作用域链：执行环境的类型总共有两种-全局和局部(函数)，有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。
- 有两种情况可以延长作用域链 try-catch的catch块和with语句。

```javascript
try{
  null.name
}catch(e) {
  console.log(e.message);
}
```

在IE9+版本的浏览器环境下，此处的catch块中临时增加了一个变量对象，延长了作用域链。

```javascript
function buildUrl() {
  var qs = "?debug=true";
  with(location) {
    var url = href + qs;
  }
  return url;
}
console.log(buildUrl());
```

with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法。
这个变量对象被添加到作用域链的前端。而with内部，定义了一个url变量，因此这个url就成了函数执行环境的一部分。可以作为函数值被返回。
没有块级作用域：js不像是C, JAVA, 不支持块级作用域, 比如if语句和for语句

```javascript
if(true) {
  var haha = 'haha';
}
console.log(haha); // haha 没在if 块中也可以访问
```

还有：

```javascript
for(var i=0;i<10;i++) {}
console.log(i); // 10 
```
