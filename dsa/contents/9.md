### 谁做的好事

- 清华附中有四位同学中的一位做了好事，不留名，表扬信来了之后，校长问这四位是谁做的好事。
    * A说:不是我。
    * B说:是C。
    * C说:是D。
    * D说:他胡说。
- 已知:三个人说的是真话，一个人说的是假话。
- 现在请你根据这些信息，编写程序找出做了好事的人。
- 分析
    * 将四个人说的四句话(自然语言)转换成计算机可以计算的式子, 可使用循环枚举的方式来判断
    * (1) 思路一：通过字符表示人
    * 先定义一个字符变量 `thisman` 表示要寻找的做了好事的人的“名字(代号)”(A、B、C、D)，即 
        * `char thisman; // 'A', 'B', 'C', 'D'`
    * 用关系表达式改写四个人说的话
        * A说“不是我” $\Rightarrow$ `thisman != 'A'`
        * B说“是C” $\Rightarrow$ `thisman == 'C'`
        * C说“是D” $\Rightarrow$ `thisman == 'D'`
        * D说“他胡说” $\Rightarrow$ `thisman != 'D'`
    * 代码实现
        ```cpp
        #include <iostream>
        using namespace std;

        int main() {
            int g = 0; // 初始化为0，表示“无解”
            // for 循环体开始 k是循环控制变量
            for (int k = 0; k < 4; k++) {
                char thisman = 'A' + k;
                int sum = (thisman != 'A') + (thisman == 'C') + (thisman == 'D') + (thisman != 'D');
                if (sum == 3){ // 如果3句话为真，则输出当前可能性所假定的人为做好事者
                    cout << "做好事者为" << thisman << endl;
                    g = 1; // 有解标志置1，表示找到解了
                }
            }
            if (g != 1) {
                cout << "找不出做好事者" << endl; // 输出无解信息
                return 0;
            }
        }
        ```
    * (2) 思路二：通过数字表示人
    * 让k表示要找的人，k从0到3，表示从A找到D
    * 用关系表达式改写四个人说的话
        * A说“不是我” $\Rightarrow$ `k != 0`
        * B说“是C” $\Rightarrow$ `k == 2`
        * C说“是D” $\Rightarrow$ `k == 3`
        * D说“他胡说” $\Rightarrow$ `k != 3`
    * 代码实现
        ```cpp
        #include <iostream>
        using namespace std;

        int main() {
            int g = 0; // 初始化为0，表示“无解” 哨兵变量
            char thisman = 'A';
            // for 循环体开始 k是循环控制变量
            for (int i = 0; i < 4; i++) {
                int k = 0;
                k += i;
                int sum = (k != 0) + (k == 2) + (k == 3) + (k != 3);
                // 如果3句话为真，则输出当前可能性所假定的人为做好事者
                if (sum == 3){
                    thisman += k;
                    cout << "做好事者为" << thisman << endl;
                    g = 1; // 有解标志置1，表示找到解了
                }
            }
            if (g != 1) {
                cout << "找不出做好事者" << endl; // 输出无解信息
                return 0;
            }
        }
        ```

### 刑侦案件

- 某地刑侦大队对涉及六个嫌疑人的一桩疑案进行分析，以下内容叙述的是刑侦队搜集到的线索和情报:
    * A、B 至少有一人作案;
    * A、E、F 三人中至少有两人参与作案;
    * A、D 不可能是同案犯;
    * B、C 或同时作案，或与本案无关;
    * C、D 中有且仅有一人作案;
    * 如果D没有参与作案，则E也不可能参与作案
- 请编写程序，将作案人找出来
- 分析
    * 同上题一样，这一题也是一个循环枚举的思想
    * 6个人中，每一个人都有2种可能，作案和没作案
    * 可以根据数学思想，作分步枚举，共有6步，所以用6个循环
    * 分别用a,b,c,d,e,f表示6个人, 同时，作案用1表示，未作案用0表示
    * 用关系表达式改写6条线索
        * A、B 至少有一人作案; $\Rightarrow$ `a || b`
        * A、E、F 三人中至少有两人参与作案; $\Rightarrow$ `(a&&e) || (a&&f) || (e&&f)`
        * A、D 不可能是同案犯; $\Rightarrow$ `!(a&&d)`
        * B、C 或同时作案，或与本案无关; $\Rightarrow$ `(b&&c) || (!b&&!c)`
        * C、D 中有且仅有一人作案; $\Rightarrow$ `(c&&!d) || (!c&&d)`
        * 如果D没有参与作案，则E也不可能参与作案 $\Rightarrow$ `d || (!d&&!e)`
    * 代码实现
        ```cpp
        #include <bits/stdc++.h>
        using namespace std;

        int main() {
        int flag = 0;
        for (int a = 0; a < 2; a++) {
            for (int b = 0; b < 2; b++) {
                for (int c = 0; c < 2; c++) {
                    for (int d = 0; d < 2; d++) {
                        for (int e = 0; e < 2; e++) {
                            for (int f = 0; f < 2; f++) {
                                if ((a || b) + ((a && e) || (a && f) || (e && f)) + (!(a && d)) + ((b && c) || (!b && !c)) + ((c && !d) || (!c && d)) + (d || (!d && !e)) == 6) {
                                    flag = 1;
                                    string A, B, C, D, E, F;
                                    A = a ? "A" : "";
                                    B = b ? "B" : "";
                                    C = c ? "C" : "";
                                    D = d ? "D" : "";
                                    E = e ? "E" : "";
                                    F = f ? "F" : "";
                                    cout << "作案人员有：" << A << B << C << D << E << F << endl;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!flag) {
            printf("未找到作案人员!");
        }
        return 0;
        }
        ```

### 下楼台阶问题

1 ) **问题描述**

- 从楼上走到楼下共有 h 个台阶，每一步有三种走法
    * 走一个台阶;
    * 走二个台阶;
    * 走三个台阶。
- 问:一共可以走出多少种方案? 即共要多少步? 每一步走几级台阶?


2 ) **分析**

**初始思路**

- 我们根据题目给定的场景，先简单模拟一下，设定 $h=4$

<div align="center">
    <img width="400" src="./screenshot/5.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 如上图所示, 这里有4阶楼梯, 红色数字代表每一步走几级台阶
- 这里枚举了4层台阶的所有可能情况, 但是不管具体有几级台阶，下楼方式都是一样的
- 如果超过3层，那么每次三种方式：1级,2级和3级，如果不超过3层，那么只有1级和2级，这可以用for循环来实现。
- 这个4层是我们建立的一种模型，如果h无限大，那么这个问题的规模将会很大，我们要找到一种统一的方式来缩小问题的规模
- 不管这个h是几，也就是说，你在第$h_i$级台阶和在第$h_k$级台阶面临的问题都是同一类问题，只有参数不同而已
- 这里有个思想就是递归
    * 试着一步一步地走，从高到低，让变量i先取台阶数h
    * 从楼上到楼下，每走一步，变量i的值会减去每一步所走的台阶数j
    * 开始时，i = h(初值)，以后 i=i-j，(j=1,2,3)
    * 当 i = 0 时，剩余台阶数为0，这说明已走到楼下
    * 每一步走法策略都相同，故可以用递归算法
- 程序实现
    ```cpp
    #include <iostream> // cout 
    using namespace std;
    // 方案细节记录在take中(take数组记录了第几步(索引)采用的下台阶方案(1,2,3))，方案数用num累计 
    int take[99], num = 0;
    void Try(int i, int s); // 有i级台阶，从第s步开始, 初始是第1步(我们这里可设定索引从1开始)

    int main() {
        cout << "请输入楼梯台阶数:"; int h;
        cin >> h; // 输入楼梯的台阶数
        Try(h, 1); // 从第h级，开始下第一步
        cout << "总方案数:" << num << endl;
        return 0; 
    }

    // 有i级台阶，从第s步开始
    void Try(int i, int s) {
        for (int j=3; j>0; j--) {
            if (i >= j) {
                // 记录第s步走j个台阶
                take[s] = j;
                // 这里是终止条件，也就是最后一步完成的条件：如果已经到了楼下，最后一步剩下的台阶数和最后一种方案一样，那么直接完成
                if (i==j) {
                    num++; // 方案数加1
                    // 已经完成输出相关方案信息
                    cout << "方案" << num << ": ";
                    // 从1开始循环输出方案数
                    for (int k=1; k<=s; k++) {
                        cout << take[k]; 
                    }
                    cout << endl;
                } else {
                    // 尚未走到楼下
                    Try(i-j, s+1); // 再试剩下的台阶
                }
            }
        }
    }
    ```
- 我们可以看到这个程序上来就是一个循环，在循环体里面套了一个自身的递归

**改进版本**

- 上面那种思维是我们日常的解决问题的思维
- 一般用递归算法的时候，为了保证不出错，上来就要做终止条件的判断，这样也更容易把问题想清楚，更为高效和准确

<div align="center">
    <img width="400" src="./screenshot/6.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 这是一张与或图，分成左右两边
- 在左边有两个分支，高度为0作为终止条件，输出；高度不为0，有三种可能性需要尝试
- 在右边是左边第二个分支的进行计算和判断的逻辑
- 上面这张图经常在递归算法中用到
- 实心黑色的圈加下面的弧线表示`与节点`；没有弧线的的实心黑圆是`或节点`
- 代码实现
    ```cpp
    #include <iostream>
    using namespace std;

    // 楼梯高度(台阶数量)
    int h;
    // 方案总数
    int num;
    // 方案内容
    int *path = new int[h];
    // 第step步，从高度height开始，继续下楼 
    void Try(int height, int step);

    int main() {
        // 让用户自己输入台阶数
        cout << "请输入楼梯台阶数:"; 
        cin >> h;
        // 总方案数初值为0
        num = 0;
        // 第0步，从高度h出发 
        Try(h, 0);
        return 0;
    }

    /// 第step步，从高度height开始，继续下楼
    void Try(int height, int step) {
        /// 递归中止条件:到达楼梯底层 
        if (height == 0) {
            num ++;
            // 输出该方案
            cout << "方案:" << num << ": ";
            // 循环输出当前方案的具体内容
            for (int i = 0; i < step; i++) {
                cout << path[i] << ' ';
            }
            // 最后换行
            cout << endl;
            return;
        }
        /// 依次尝试不同的下楼步数(循环变量i是步数) 
        for (int i = 1; i <= 3; i++) {
            // 1. 计算新高度
            int new_height = height - i;
            // 2. 高度是否可行?
            if (new_height < 0) continue;
            // 3. 记录当前步数
            path[step] = i;
            // 4. 继续向目标前进, 自身递归运算
            Try(new_height, step+1);
        }
    }
    ```