### 编程输出N*N的数字方阵

1 ) **任务**

- 编程输出N*N的数字方阵，将1~N*N的自然数逆时针旋转填充到矩阵中。例如一个6*6的矩阵完成填充后的示意图如下所示

<div align="center">
    <img width="400" src="./screenshot/29.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

2 ) **一般思路**

- 每次填完一个矩形，剩下的又是一个矩形
- 每次矩形的起点都不一样，如下图所示：1，21，33

<div align="center">
    <img width="400" src="./screenshot/30.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 每一次小的矩形填写都与前一个矩形有类似的算法实现，我们自然想到了递归实现
- 设函数Fill(number, begin, size)表示将number开头的数，从位置(begin, begin)开始填写，矩阵大小为size*size
- 递归算法的与或图如下

<div align="center">
    <img width="400" src="./screenshot/31.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 形象的描述为下图：

<div align="center">
    <img width="400" src="./screenshot/32.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 代码实现

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int m[6][6] = {{0}};

void Show() {
    for (int i=0; i<6; i++) {
        for (int j=0; j<6; j++)
            cout << setw(2) << m[i][j] << ' '; cout << endl;
    } 
}

void Fill(int num, int begin, int size);

int main() {
    Fill(1, 0, 6);
    Show();
    return 0;
}

void Fill(int num, int begin, int size) { 
    if (size == 0) return;
    if (size == 1) {
        m[begin][begin] = num;
        return;
    }
    // 四个边的遍历
    for (int j=0; j<size-1; j++) m[begin+j][begin+0] = num++; 
    for (int j=0; j<size-1; j++) m[begin+size-1][begin+j] = num++; 
    for (int j=size-1; j>0; j--) m[begin+j][begin+size-1] = num++; 
    for (int j=size-1; j>0; j--) m[begin+0][begin+j] = num++; 
    Fill(num, begin+1, size-2);
}
```

- 输出结果：

```shell
 1 20 19 18 17 16 
 2 21 32 31 30 15 
 3 22 33 36 29 14 
 4 23 34 35 28 13 
 5 24 25 26 27 12 
 6  7  8  9 10 11
```

- 当然这个6可以很容易的抽离出来变为n, 由用户填写可得N*N的矩阵

3 ) **使用OOP的思路来做**

- TODO