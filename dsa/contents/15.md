### 编程输出N*N的数字方阵

1 ) **任务**

- 编程输出N*N的数字方阵，将1~N*N的自然数逆时针旋转填充到矩阵中。例如一个6*6的矩阵完成填充后的示意图如下所示

<div align="center">
    <img width="400" src="./screenshot/29.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

2 ) **一般思路**

- 每次填完一个矩形，剩下的又是一个矩形
- 每次矩形的起点都不一样，如下图所示：1，21，33

<div align="center">
    <img width="400" src="./screenshot/30.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 每一次小的矩形填写都与前一个矩形有类似的算法实现，我们自然想到了递归实现
- 设函数Fill(number, begin, size)表示将number开头的数，从位置(begin, begin)开始填写，矩阵大小为size*size
- 递归算法的与或图如下

<div align="center">
    <img width="600" src="./screenshot/31.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- Fill的过程形象的描述为下图：

<div align="center">
    <img width="400" src="./screenshot/32.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 代码实现

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int m[6][6] = {{0}};

void Show() {
    for (int i=0; i<6; i++) {
        for (int j=0; j<6; j++)
            cout << setw(2) << m[i][j] << ' '; cout << endl;
    } 
}

void Fill(int num, int begin, int size);

int main() {
    Fill(1, 0, 6);
    Show();
    return 0;
}

void Fill(int num, int begin, int size) { 
    if (size == 0) return;
    if (size == 1) {
        m[begin][begin] = num;
        return;
    }
    // 四个边的遍历
    for (int j=0; j<size-1; j++) m[begin+j][begin+0] = num++; 
    for (int j=0; j<size-1; j++) m[begin+size-1][begin+j] = num++; 
    for (int j=size-1; j>0; j--) m[begin+j][begin+size-1] = num++; 
    for (int j=size-1; j>0; j--) m[begin+0][begin+j] = num++; 
    Fill(num, begin+1, size-2);
}
```

- 输出结果：

```shell
 1 20 19 18 17 16 
 2 21 32 31 30 15 
 3 22 33 36 29 14 
 4 23 34 35 28 13 
 5 24 25 26 27 12 
 6  7  8  9 10 11
```

- 当然这个6可以很容易的抽离出来变为n, 由用户填写可得N*N的矩阵

3 ) **使用OOP的思路来做(优化版)**

- 在面向对象OOP中，可以借助对象来执行相应的方法来做
- 代码实现

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

class matrix {
    int **M;
    int N;

public:
    void init(int size);
    void fill(int num, int begin, int size);
    void print();
    void clear();
};

void matrix::init(int size) {
    // 初始化数据结构：N*N的矩阵
    // 用下面这种方式初始化一个N*N的矩阵
    M = new int*[size];
    N = size; // 用于后面的打印和清理
    // r means 'row'
    for (int r=0; r<size; r++) {
        M[r] = new int[size];
        memset(M[r], 0, sizeof(int)*size); // 矩阵清零，表示无数字 
    }
}

void matrix::fill(int num, int begin, int size) {
    if (size == 0) {
        return;
    }
    if (size == 1) {
        M[begin][begin] = num;
        return;
    }
    // 四个边的遍历
    for (int j=0; j<size-1; j++) M[begin+j][begin+0] = num++;
    for (int j=0; j<size-1; j++) M[begin+size-1][begin+j] = num++;
    for (int j=size-1; j>0; j--) M[begin+j][begin+size-1] = num++;
    for (int j=size-1; j>0; j--) M[begin+0][begin+j] = num++;
    fill(num, begin+1, size-2);
}

// print 打印矩阵格子
void matrix::print() {
    for (int i = 0; i < N; i++) {
        for (int j=0; j< N; j++) {
            cout << setw(2) << M[i][j] << ' ';
        }
        cout << endl;
    }
}

void matrix::clear() {
    for (int r=0; r<N; r++) delete[] M[r];
    delete[] M;
}

int main() {
    matrix obj;
    cout << "Please input N: ";
    int size; 
    cin >> size;
    obj.init(size); // 根据输入大小做准备
    obj.fill(1, 0, size); // 按规则完成数字填充
    obj.print(); // 输出填充结果
    obj.clear(); // 一些必要的善后处理
    return 0;
}
```

- 当然，除了这一种递归算法，也可以通过制定一些走路的规则来填充矩阵，如下图

<div align="center">
    <img width="400" src="./screenshot/33.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 把画矩形这事抽象成一个小人走格子，每走一个格子就写一个值，一路走下去，当然走的规则需要进行指定，一些规则参考如下：

```cpp

class matrix {
    char dir; // 'D', 'R', 'U', 'L' 注：这里有四个边，左下右上，逆时针方向，其中左边的方向是向下，用D来表示，其他依次类推
}

// 'D', 'R', 'U', 'L' 注：这里有四个边，左下右上，逆时针方向，其中左边的方向是向下，用D来表示，其他依次类推
void matrix::place(int num) {
    // 根据前一位置、方向，以及摆放规则(DRUL)确定下一个摆放数据的位置
    switch (dir) {
        case 'D':
            // 先保证row在合法范围内，再考虑该处是否已有数字(是否为0) 
            if (row < N-1 && M[row+1][col] == 0) row++; 
            else {
                dir = 'R'; // next direction
                col++;
            }
            break;
        // 仅展示部分源码
        // ...
}
```

- 一路走下图，如图：

<div align="center">
    <img width="400" src="./screenshot/34.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 可以看到，填充算法的执行过程与矩阵结构有关，两者紧密耦合

### 场景变化

- 我们所处的世界复杂多变，就这一类填充问题，就可以有无数的变形。
- 如果旋转方向从逆时针变成顺时针，则程序应该如何修改?
- 如果希望两种旋转方向的填充策略都能支持，程序又应该如何修改?
- 更进一步地，如果希望扩展到其他类型的填充次序，如蛇形、Z字形、U字形...等，应该如何修改类的对外接口与具体实现?

<div align="center">
    <img width="700" src="./screenshot/35.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 进一步我们深入思考矩阵到底是什么？
