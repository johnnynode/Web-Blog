图搜索 Graph Search
---

### 图搜索的分类

- BFS广度优先(宽搜)
- DFS深度优先(深搜) !!!本文详解!!!

### 深度优先搜索DFS

- 深度优先遍历DFS, 这个策略其实是非常stupid or simple的，比BSF要简单的多
- 同样，我们可以通过一个故事来开始
    * 在古希腊神话中, Ariadne是Crete的国王Minos的公主，她给忒修斯(Theseus)一个线团
    * 使得忒修斯成功进入迷宫杀死牛头怪兽，但事后忒修斯抛弃了她
    * 这是一个有道德意义的故事又或者存在不同的版本, 但不是我们的研究的对象
    * 假如你是一位探险家，要降落在一片未知的迷宫做路线探测
    * 比如降落在一个地点(某一点)，你要知道这个点有几条边(方向)到达潜在的拐点
    * 在任何一个点你都应该知道，当然可以做一个标记，比如撒上一点荧光剂(任何实用东西都可)
    * 标记是用来标识出自己走过的地方，接下来的任务就是要把该区域可达路径画出来
    * 不失一般性，我们先画一个未知的路线图，我们随便画一幅图，如下图
    * 我们假设一开始自己未知路线，这个路线图是上帝视角，人类未知(灰色)，只能一点点探索
    * 我们可以把上帝视角下的所有拐点标记为：A,B,...H，以备后续的说明使用
    * 假设我们的降落地点是红色的A点，一开始就通向2个方向，不同于BFS，DFS不能多向走，只能选择一个方向
    * 不失一般性，我们可以选择向下去的一条(绿边)，如下图4所示，持续向下走，会抵达一个拐点，蓝色点，如图5
    * 接下来你会发现又出现了3条可走的路线，你可以继续任意选择一个方向，如下图6所示
    * 继续往前走，每走到一个拐点，就进行一次标记(比如洒下荧光剂)，你会发现这个过程有点stupid
    * 简单来说，就一条路跑到黑，基于这个策略其实是非常美妙的，可以解决很多算法解决不了的问题
    * 这时候，你已经走到如图9的位置了，你会发现似乎有一条边可以过去，但是走过去之后发现了自己洒下的标记
    * 你会知道，这个方向通往的地方，你曾经访问过，这时候这条边可以做一个特别的记号，就是所谓的跨边，如图10所示
    * 按照惯例，我们访问过的这些绿色的边，叫做TREE EDGE, 而灰色的跨边叫做CROSS(因为会构成环路)
    * 当我们发现走进了跨边之后，就要进行回退，因为绿色的边构成的是一棵树
    * 而树中的任意两个点之间有唯一的通路，所以回退的方向是唯一的，就是逐个找到自己的parent
    * 回退到B点之后发现有2条可选的路，我们很快会发现其中有一条路存在标记(CROSS边)
    * 于是就剩下最后一个方向了，如下图11所示，继续往前走，到达拐点，如图12所示，紧接着发现还有3条可选的路
    * 继续按着以往的策略任选一条，如下图13，14，15，到达图16的时候，又会标记一条CROSS边，如图17
    * 继续做回退，当到达E点的时候，发现又可以往前走，最终到达一个死胡同，如图19所示，这样只能继续回退一直到初始红点A
    * 然后对新发现的CROSS边进行标记，如图20，到这个时候，整个遍历完成

<div align="center">
    <img width="700" src="./screenshot/153.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

**算法实现框架**

```cpp
template <typename Tv, typename Te> // 顶点类型、边类型

void Graph<Tv, Te>:: DFS(int v, int & clock) {
    // v是起点，clock是计时器，dTime为每个点都加上时间戳
    dTime(v) = ++clock;
    status(v) = DISCOVERED; // 发现当前顶点v
    // 考察v的每一邻居u，枚举所有的邻居，这里的邻居都是当前节点的孩子节点
    for (int u = firstNbr(v); -1 < u; u = nextNbr(v,u)) {
        // 视u的状态，分别处理
        switch(status(u)) {
            case UNDISCOVERED: // u 尚未发现，意味着支撑树可在此拓展 (类比BFS的初始植被状态)
                type(v, u) = TREE; // 树枝向前迈进
                parent(u) = v; // 从v到孩子u之间的关系
                DFS(u, clock); // 新的起点，开始递归，向孩子节点进发，贪心处理
                break;
            case DISCOVERED: // u 已被发现但尚未访问完毕，应属被后代指向的祖先 (类比BFS的燃烧状态)
                type(v, u) = BACKWARD; // 这是一条回边，进行标记处理
                break;
            default: // u已访问完毕(VISITED, 有向图)，则视承袭关系分为前向边或跨边 (类比BFS的灰烬状态)
                // 通过时间戳来判断是向前边还是跨边
                type(v,u) = dTime(v) < dTime(u) ? FORWARD : CROSS;
                break;
        }
    }
    status(v) = VISITED; // 处理完所有孩子节点之后，标记自己为已访问
    fTime(v) = ++clock; // 至此，当前顶点v方告访问完毕，fTime是指结束时间
}
```

- 我们可以看到上述算法中有4种边：TREE、FORWARD、BACKWARD、CROSS, 下面我们会详细来说明

### DFS算法步骤图解

<div align="center">
    <img width="700" src="./screenshot/154.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 上面是一个有向图, 每一个节点都是一个圆角矩形，不失一般性，我们从a开始
- 圆角矩形上的每个点都有左右两个空间用于记录dTime, fTime的数字
- 圆角矩形的颜色和状态分别对应：绿色(UNDISCOVERED), 鲜红(最活跃的点), 暗红(活跃的点), 蓝色(VISITED)
- 大小写用于辅助颜色的区分, 如果可以看清颜色, **可以忽略字母的大小写**, 此处不再过多说明
- 对于a来说，作为起点, 在第一个单位时间内会被点着，从绿色变成鲜红，a接过控制权之后，去找到他的邻居
- 请注意这时候，它会贪心的找邻居中的一个优先做，不失一般性，在第二个单位时间把b点燃
- 这时候b变成鲜红色，a从鲜红变为暗红，立足于b, 真正的邻居只有c, 这个时候在第三个时间单位
- c被点燃变为鲜红，b变为暗红，因为是有向图，c点走投无路就会执行代码中的default，变为VISITED状态的蓝色
- 而且c点的fTime进行clock++, 从3变为4，意味着这个点从第3个时间单位被发现，但在第4个时间单位被耗尽了
- 这个时候程序是递归的，在递归的意义上它会做一个回溯(backtrack)，从c到b, b的颜色从暗红变为鲜红
- 这时候b想要找周围的邻居，发现已经没有可找的邻居了，b点走投无路变为蓝色，它的fTime变为了5
- 同理，继续进行回溯，从b到a，a从暗红变为鲜红，a还有邻居，如c,f, 如果选择邻居c, 那么这时候就有意思了
- 当前活跃的点a试图通过一条有向边去指向死亡状态的点c，这种情况在有向图才会发生
- 如果不是有向图，而是无向图，每一条边都是对等的，当一开始到达c点的时候，c不会变为蓝色而是会去找无向图中的邻居, 比如a
- 所以这是一件不可能的事情，在有向图中才会发生这种奇特的现象：活跃指向死亡, 从a->c这种
- 按照程序中的设定，dTime(a) < dTime(c), 这时候a->c是一条FORWARD的边，在图上标记为粉红色的边
- 如何理解这个FORWARD边，绿色的箭头都是将来构成树的树枝，一旦构成树就会有辈分高低之分
- c的备份从图上看要比a低2层, 就像是爷爷照顾孙子，我们称之为FORWARD
- 好的，回到流程中来，标记完a->c为FORWARD边之后，a要继续寻找它的邻居，这里找到了f点
- 此时, f的dTime为6，f会试图在第7个时间单位找到g, g会继续寻找它的邻居：a和c
- 好的，这个时候，故事又来了, a的辈分很高, a是g的祖先，我们称之为BACKWARD边(可以理解为孙子照顾爷爷)
- 打个比方，当Theseus在迷宫漫游的时候，他把线团的一头记在了迷宫的洞口，在迷宫中的"遍历"的过程中
- 手里始终攥着那个绳子的线团，每向前走一步，就把线团放一步, 每一次做backtrack, 手就会收这个线团
- 因为收放，绳子忽长忽短，正是这条绳子，可以让他原路返回。回到算法中来，每一个节点都是辈分明确的
- Theseus的线就像是上图中任意时刻红色节点和它们的连边，关于辈分就像是绳子一样, 末端的点辈分最低
- 辈分低的到辈分高的方向的边就叫做BACKWARD边，用浅蓝色箭头表示，如g->a
- 从图上可以看出，每一次BACKWARD的出现，就会构成一个环
- 所谓的环，如果在有向图中是有方向的，如a->f->g->a
- 而a->b->c并不能构成一个环，因为方向的原因，a->c属于FORWARD边
- 这个时候，我们可以判断一个图是否是树，以及找出图中所有的环
- 好的，再次回到流程中来，g会继续寻找它的邻居，找到了c, 这个时候活跃点g试图连接死亡的点c
- 这个情况之前也碰到过，如a试图连接c, 但不同的是，dTime(g) < dTime(c), 这时候g->c就是一条CROSS边
- 所谓CROSS边的理解是共同祖先如a点的不同直系分支下的点，g和c不构成直系的血缘关系，可能是叔伯兄弟的关系
- 也就是跨越两个家族之间的边就是CROSS边，这个算法可以继续跑下去，直到最后
