图搜索 Graph Search
---

### 图搜索的分类

- BFS广度优先(宽搜)
- DFS深度优先(深搜) !!!本文详解!!!

### 深度优先搜索DFS

- 深度优先遍历DFS, 这个策略其实是非常stupid or simple的，比BSF要简单的多
- 同样，我们可以通过一个比喻来进行解释
    * 你是一位探险家，要降落在一片未知的荒野做路线探测
    * 比如降落在一个地点(某一点)，你要知道这个点有几条边(方向)到达潜在的拐点
    * 在任何一个点你都应该知道，当然可以做一个标记，比如撒上一点荧光剂(任何实用东西都可)
    * 标记是用来标识出自己走过的地方，接下来的任务就是要把该区域可达路径画出来
    * 不失一般性，我们先画一个未知的路线图，我们随便画一幅图，如下图
    * 我们假设一开始自己未知路线，这个路线图是上帝视角，人类未知(灰色)，只能一点点探索
    * 我们可以把上帝视角下的所有拐点标记为：A,B,...H，以备后续的说明使用
    * 假设我们的降落地点是红色的A点，一开始就通向2个方向，不同于BFS，DFS不能多向走，只能选择一个方向
    * 不失一般性，我们可以选择向下去的一条(绿边)，如下图4所示，持续向下走，会抵达一个拐点，蓝色点，如图5
    * 接下来你会发现又出现了3条可走的路线，你可以继续任意选择一个方向，如下图6所示
    * 继续往前走，每走到一个拐点，就进行一次标记(比如洒下荧光剂)，你会发现这个过程有点stupid
    * 简单来说，就一条路跑到黑，基于这个策略其实是非常美妙的，可以解决很多算法解决不了的问题
    * 这时候，你已经走到如图9的位置了，你会发现似乎有一条边可以过去，但是走过去之后发现了自己洒下的标记
    * 你会知道，这个方向通往的地方，你曾经访问过，这时候这条边可以做一个特别的记号，就是所谓的跨边，如图10所示
    * 按照惯例，我们访问过的这些绿色的边，叫做TREE EDGE, 而灰色的跨边叫做CROSS(因为会构成环路)
    * 当我们发现走进了跨边之后，就要进行回退，因为绿色的边构成的是一棵树
    * 而树中的任意两个点之间有唯一的通路，所以回退的方向是唯一的，就是逐个找到自己的parent
    * 回退到B点之后发现有2条可选的路，我们很快会发现其中有一条路存在标记(CROSS边)
    * 于是就剩下最后一个方向了，如下图11所示，继续往前走，到达拐点，如图12所示，紧接着发现还有3条可选的路
    * 继续按着以往的策略任选一条，如下图13，14，15，到达图16的时候，又会标记一条CROSS边，如图17
    * 继续做回退，当到达E点的时候，发现又可以往前走，最终到达一个死胡同，如图19所示，这样只能继续回退一直到初始红点A
    * 然后对新发现的CROSS边进行标记，如图20，到这个时候，整个遍历完成

<div align="center">
    <img width="700" src="./screenshot/153.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

**算法实现框架**

```cpp
template <typename Tv, typename Te> // 顶点类型、边类型

void Graph<Tv, Te>:: DFS(int v, int & clock) {
    dTime(v) = ++clock; status(v) = DISCOVERED; // 发现当前顶点v
    // 考察v的每一邻居u
    for (int u = firstNbr(v); -1 < u; u = nextNbr(v,u)) {
        // 视u的状态，分别处理
        switch(status(u)) {
            case UNDISCOVERED: // u 尚未发现，意味着支撑树可在此拓展
                type(v, u) = TREE;
                parent(u) = v;
                DFS(u, clock); // 递归
                break;
            case DISCOVERED: // u 已被发现但尚未访问完毕，应属被后代指向的祖先
                type(v, u) = BACKWARD;
                break;
            default: // u已访问完毕(VISITED, 有向图)，则视承袭关系分为前向边或跨边
                type(v,u) = dTime(v) < dTime(u) ? FORWARD : CROSS;
                break;
        }
    }
    status(v) = VISITED;
    fTime(v) = ++clock; // 至此，当前顶点v方告访问完毕
}
```
