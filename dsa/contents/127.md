### 排序

- 排序：把某个乱序的数组变成升序或降序的数组 (这里用数组来做举例)

### 快速排序

- 该排序属于 **分治** 策略
- 将一个问题分解为两个问题来计算，计算完成之后，就会得到子任务的解，这些解不是最终问题的解，还需要merge起来

### 算法实现

```js
Array.prototype.quickSort = function() {
    const rec = (arr) => {
        if(arr.length === 1) {
            return arr;
        }
        // 开始分区操作
        let l = [];
        let r = [];
        let m = arr[0]; // 选择当前第一个元素作为基准
        let len = arr.length;
        // 从第二项开始分区，除了基准，这样好分
        for(let i = 1; i < len; ++i) {
            if(arr[i] < m) {
                l.push(arr[i]);
            } else {
                r.push(arr[i])
            }
        }

        // 开始递归分区与合并
        return [...rec(l), mid, ...rec(r)];
    }
    // 得到最终递归结果
    const r = rec(this);
    // 将递归结果挂载到自身
    r.forEach((n, i) => {this[i] = n})
}

let arr = [15,4,23,52,1]
arr.insertionSort()
console.log(arr); //  [1, 4, 15, 23, 52]
```

- 比冒泡，选择，插入性能都要好, 分而治之
- Chrome 曾经用快排作为sort排序的方法
- 思路
    * 分区：从数组中，任意选择一个基准，所有比基准小的元素放在基准前面，比基准大的元素放在基准后面
        * 此时，基准已经找到自己合适的位置了
    * 递归：递归地对基准前后的子数组进行分区
        * 在子数组中找到一个基准，并把它放到合适的位置
        * 一直递归下去，基准前后子数组最后的长度都是1，不用再递归了，此时子数组已经排序好了
        * 等所有子数组都排序好，我们整个快排结束
- 时间复杂度: O(nlogn)
    * 递归时间: logn, 每次劈成2半
    * 分区时间：n，for循环，找出比基准小和大的元素
