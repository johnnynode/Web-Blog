### 直方图最大面积

**问题描述**

- 有n列的直方图，第j列高度为$h_j$, 求一个面积最大的子矩阵

**格式要求**

- 输入第一行正整数n，第二行n个空格隔开的非负整数
- 数据范围: 所有直方图的列不会超过30000
**分析**

- 矩形面积为底和高的乘积
- 底部从a到b，那么底边长为: b-a+1
- 高为：$min \{h_i | a \leq i \leq b \}$
- 面积：(b-a+1) * $min \{h_i | a \leq i \leq b \}$
- 蛮力算法：枚举每一条可能的底边, 计算出高, 求出面积再取一个最大的

### 关键算法实现

**算法1：时间复杂度为: $O(n^3)$的实现**

```cpp
int getResult(int n, int *h) {
    // 最后答案
    int res = 0;
    // 第一层循环枚举直方图左边界位置
    for (int a = 1; a <= n; ++a) {
        // 第二层循环枚举直方图右边界位置
        for (int b = a; b <= n; ++b) {
            // 记录最小高度, 要求是不超过3w, 这里只做数据的初始化
            int minH = 50000;
            // 从a到b更新最小高度
            for (int c = a; c <= b; ++c) {
                minH = min(minH, h[c]); // 更新最小高度
            }
            res = max(res, (b - a + 1) * minH); // 更新最大面积
        }
    }
    return res;
}
```

总结：太慢了，属于比较原始的蛮力算法，没有任何优化的算法, 这是能够直接想到的

**算法2：减少循环, 时间复杂度为: $O(n^2)$的实现优化版本**

```cpp
int getResult(int n, int *h) {
    // 最后答案
    int res = 0;
    // 第一层循环枚举直方图左边界位置
    for (int a = 1; a <= n; ++a) {
        // 记录最小高度, 要求是不超过3w, 这里只做数据的初始化
        int minH = 50000;
        // 第二层循环枚举直方图右边界位置
        // 思路：a到b的最小高度H1 和 a到b+1的最小高度H2的关系：H2=min(H1, h_{b+1})
        // 由此减少了一次循环
        for (int b = a; b <= n; ++b) {
            minH = min(minH, h[b]); // 更新最小高度
            res = max(res, (b - a + 1) * minH); // 更新最大面积
        }
    }
    return res;
}
```

总结：优化思路是在a和b的底之间找到最小高度

**算法3：通过卡位来计算，时间复杂度为: $O(n^2)$的实现优化版本**

```cpp
// todo
```

**算法4：通过单调栈来计算，时间复杂度为: $O(n^2)$的实现优化版本**

总结：对于每一列, 找到左右两端的卡位hi和lo, 形成的矩形面积为：(hi - lo - 1) * hi

### 相关说明

- 普通电脑中运算$10^8$是可以的, 到了9次方就会变慢, 同样的道理，服务器也是一样都会有一定的瓶颈，我们追求速度的话，一定要优化复杂度, 但蛮力算法通常是解决问题的第一步。
- 一般而言，优化顺序是：蛮力、贪心、减治、分治