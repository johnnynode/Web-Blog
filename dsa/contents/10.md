
### 下台阶问题

1 ) **问题描述**

- 从楼上走到楼下共有 h 个台阶，每一步有三种走法
    * 走一个台阶;
    * 走二个台阶;
    * 走三个台阶。
- 问:一共可以走出多少种方案? 即共要多少步? 每一步走几级台阶?


2 ) **分析**

**初始思路**

- 我们根据题目给定的场景，先简单模拟一下，设定 $h=4$

<div align="center">
    <img width="400" src="./screenshot/5.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 如上图所示, 这里有4阶楼梯, 红色数字代表每一步走几级台阶
- 这里枚举了4层台阶的所有可能情况, 但是不管具体有几级台阶，下楼方式都是一样的
- 如果超过3层，那么每次三种方式：1级,2级和3级，如果不超过3层，那么只有1级和2级，这可以用for循环来实现。
- 这个4层是我们建立的一种模型，如果h无限大，那么这个问题的规模将会很大，我们要找到一种统一的方式来缩小问题的规模
- 不管这个h是几，也就是说，你在第$h_i$级台阶和在第$h_k$级台阶面临的问题都是同一类问题，只有参数不同而已
- 这里有个思想就是递归
    * 试着一步一步地走，从高到低，让变量i先取台阶数h
    * 从楼上到楼下，每走一步，变量i的值会减去每一步所走的台阶数j
    * 开始时，i = h(初值)，以后 i=i-j，(j=1,2,3)
    * 当 i = 0 时，剩余台阶数为0，这说明已走到楼下
    * 每一步走法策略都相同，故可以用递归算法
- 程序实现
    ```cpp
    #include <iostream> // cout 
    using namespace std;
    // 方案细节记录在take中(take数组记录了第几步(索引)采用的下台阶方案(1,2,3))，方案数用num累计 
    int take[99], num = 0;
    void Try(int i, int s); // 有i级台阶，从第s步开始, 初始是第1步(我们这里可设定索引从1开始)

    int main() {
        cout << "请输入楼梯台阶数:"; int h;
        cin >> h; // 输入楼梯的台阶数
        Try(h, 1); // 从第h级，开始下第一步
        cout << "总方案数:" << num << endl;
        return 0; 
    }

    // 有i级台阶，从第s步开始
    void Try(int i, int s) {
        for (int j=3; j>0; j--) {
            if (i >= j) {
                // 记录第s步走j个台阶
                take[s] = j;
                // 这里是终止条件，也就是最后一步完成的条件：如果已经到了楼下，最后一步剩下的台阶数和最后一种方案一样，那么直接完成
                if (i==j) {
                    num++; // 方案数加1
                    // 已经完成输出相关方案信息
                    cout << "方案" << num << ": ";
                    // 从1开始循环输出方案数
                    for (int k=1; k<=s; k++) {
                        cout << take[k]; 
                    }
                    cout << endl;
                } else {
                    // 尚未走到楼下
                    Try(i-j, s+1); // 再试剩下的台阶
                }
            }
        }
    }
    ```
- 我们可以看到这个程序上来就是一个循环，在循环体里面套了一个自身的递归

**改进版本**

- 上面那种思维是我们日常的解决问题的思维
- 一般用递归算法的时候，为了保证不出错，上来就要做终止条件的判断，这样也更容易把问题想清楚，更为高效和准确

<div align="center">
    <img width="400" src="./screenshot/6.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 这是一张与或图，分成左右两边
- 在左边有两个分支，高度为0作为终止条件，输出；高度不为0，有三种可能性需要尝试
- 在右边是左边第二个分支的进行计算和判断的逻辑
- 上面这张图经常在递归算法中用到
- 实心黑色的圈加下面的弧线表示`与节点`；没有弧线的的实心黑圆是`或节点`
- 代码实现
    ```cpp
    #include <iostream>
    using namespace std;

    // 楼梯高度(台阶数量)
    int h;
    // 方案总数
    int num;
    // 方案内容
    int *path = new int[h];
    // 第step步，从高度height开始，继续下楼 
    void Try(int height, int step);

    int main() {
        // 让用户自己输入台阶数
        cout << "请输入楼梯台阶数:"; 
        cin >> h;
        // 总方案数初值为0
        num = 0;
        // 第0步，从高度h出发 
        Try(h, 0);
        return 0;
    }

    /// 第step步，从高度height开始，继续下楼
    void Try(int height, int step) {
        /// 递归中止条件:到达楼梯底层 
        if (height == 0) {
            num ++;
            // 输出该方案
            cout << "方案:" << num << ": ";
            // 循环输出当前方案的具体内容
            for (int i = 0; i < step; i++) {
                cout << path[i] << ' ';
            }
            // 最后换行
            cout << endl;
            return;
        }
        /// 依次尝试不同的下楼步数(循环变量i是步数) 
        for (int i = 1; i <= 3; i++) {
            // 1. 计算新高度
            int new_height = height - i;
            // 2. 高度是否可行?
            if (new_height < 0) continue;
            // 3. 记录当前步数
            path[step] = i;
            // 4. 继续向目标前进, 自身递归运算
            Try(new_height, step+1);
        }
    }
    ```