### 关于算法

- 算法其实有无数种，就市面上的算法而言，普通人可能知道的算法不到千百分之一，但是我们却可以一定程度上驾驭算法，是因为我们知道算法设计的策略
- 我们在解决问题的时候，头脑中想到的都是策略，这些算法可以串成一串，每一串可能都是基于一种策略设计出来的

### 贪心 greedy 策略

- 贪心策略强调的是眼前能看到的，一种苟且的东西
- 也就是关注的只是这个问题当下的局部，使它最大化，使它朝向最后的目标最大化

### Big-O 记号

- 我们研究算法，需要懂得如何判断算法的优劣，越好的算法消耗的资源就越少
- 计算的资源有两点：一个是时间，另一个空间，我们最主要关注的其实还是时间

<div align="center">
    <img width="600" src="./screenshot/47.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 同一个算法在解决某一个问题的时候，针对不同的n(问题的规模), 它所需要的时间成本running time, 画成一条曲线T(n)
- T(n)这个函数就是当我们给定了一个规模为n的特例之后，用这个算法在某一个特定n所需要消耗的时间成本，一般来说，是一条这样的曲线。
- 在实际情况中，并不能精确得到这条曲线，其实也没有必要得到这条曲线，我们只要知其大略即可，即粗略的估计
- T(n) = O(f(n))
    * 用一个f(n)去粗略的估计T(n), 如果这个估计可行的话，再在其前面加个O，这样来表示。
    * 可以估计的条件：$\exists \ c > 0 \ \ s.t. \ \ T(n) < c·f(n) \ \ \ \forall n >> 2$
        * 取一个c，当问题规模足够大的时候(这里$\forall n >> 2$表示足够大)，使得 $T(n) < c·f(n)$
        * 也就是这时候的$c·f(n)$ 可以估计T(n), 这个f(n)的曲线如上图虚线表示
        * 这样估计的好处是：常系数，低次项从此可忽略，即：$O(f(n)) = O(c·f(n)) \ \ ; \ \ O(n^a + n^b) = O(n^a), a \geq b > 0$
        * 举个例子：$E_x : \sqrt{5n · [3n · （n + 2) + 4] + 6} < \sqrt{5n · [6n^2 + 4] + 6 <  \sqrt{35n^3 + 6} < 6 · n^{1.5} = O(n^{1.5})}$

