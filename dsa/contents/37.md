动态规划 Dynamic Programming(DP)
---

### 引语

- 从上一篇文章中我们知道了为什么要做动态规划以及它是怎么一回事
- 动态规划基于原本递归的算法(效率低，会引起指数爆炸)，倒过来
- 递归是把原本复杂的事情变得简单，而动态规划是从最基础最简单的事情开始
- 从基础打起，一层一层很有耐心的把它算出来
- 也就是由几种子任务的递归结构转化成递推结构，换句话说
- 从递归的思路开始，不要扔掉它，它会给你一个解决方案(逻辑上的计算方式)
- 在真正实现的时候，把它倒过来计算，仅此而已

### LCS: Longest Common Subsequence 最长公共子序列

<div align="center">
    <img width="800" src="./screenshot/171.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 我们这里考虑的序列是字符串序列(string sequence)
- 某一天你可能会遇到两个string的问题, 每个string中元素都是有顺序的
- 如果你可以任意从中挑出几个字符排列起来，这样得到的序列就相对于之前序列叫做子序列
- 给你一对序列，从中分别抽出一些字符作为子序列，有时候非常的巧
- 挑出的两个子序列中含有相同的字符，我们称之为公共子序列, 显然这是取决于运气的
- 有的时候很容易得到，有的时候很难得到，有的时候完全没有公共子序列，我们要研究的是公共子序列的最长者
- 而有的时候最长的公共子序列可能包含多个，如上图的`DATA`和`DANA`，长度都是4
- 同时我们看到由顺序问题和多种选择引起的歧义，如上图下半部分的两图，所以我们先收敛一下
- 我们的问题主要是专注研究任何一对足够长的序列，在其中找出最长的子序列, 如何寻找呢？
- 我们倒过来看，我们有两个序列A和B, 不失一般性，A短，B长，无所谓的
- 它们末尾的末元素(字符)X，我们问一个问题，它俩是一样的么？答案肯定有两种：一样和不一样
- 如果一样，就在其前面切一刀，如下图所示，把它降解为更小的一个任务，前后任务长度差1
- 比如，我们要求`didacticA`和`advantA`的公共子串, 只需要再求`didactic`和`advant`的公共子串即可
- 这种情况，我们通过减而治之的方式来求解

<div align="center">
    <img width="600" src="./screenshot/172.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 如果不一样，也就是最后两个字符不同，这时候我们通过分而治之，把原来的任务分解为两个子任务

<div align="center">
    <img width="600" src="./screenshot/173.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 其中一个任务是，把一个字符串的末字符砍掉，另一个字符串的末字符保留
- 另一个任务是，把一个字符串的末字符保留，另一个字符串的末字符砍掉
- 如上图所示，把原先一个任务被分解为两个子任务了
- 这样的话最终的公共最长子串可以从这两个子任务中得到，只需要在二者之间取一个最大者即可
- 我们无非就是做上面的减而治之和分而治之来把最终的问题解决掉
- 从大体来看，我们可以把两个字符串通过坐标的形式来展示，坐标原点在左上角
- 如下图所示，有两个例子，任选其一即可

<div align="center">
    <img width="700" src="./screenshot/174.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 这么对齐来看的话，我们可以看到有一个矩阵，矩阵的每一个格子都对应一个子任务
- 一般而言，对于一个第i行，第j列的格子，用d(i,j)来表示，我们可以从坐标上得到两个新的字符串
- 横向的是0~j的字符串，纵向上是0~i的字符串，换句话说，我们只需要计算这两个新的字符串的LCS即可
- d(i,j)上LCS问题的解，从逻辑上来说就是这样的
- 如果我们要计算最左下角格子，也即是最终的任务(原始两字符串的LCS)
- 要考虑三种情况，一种是向上的，一种是向左的，一种是沿对角线方向(右下->左上)的递归
- 这些可能取决于`A[n]`(A字符串的末字符)和`B[m]`(B字符串的末字符)是否能够匹配
- 从递归上来说，会有子任务生成出来，会造成可怕的指数爆炸，这是逻辑上可行的
- 方法我们有了，我们要转过来，求助于递推，因为对于任何两个字符串，我们都会有递归基(递推基)
- 我们知道第一行都是0，从第二行开始才会有相应的值，我们可以用一种填表的方式来完成矩阵的填写
- 矩阵本身就是一个look-up table, 我们通过这些天然的递推基(字符串上的字符)
- 就可以给自己下面，右面，对角线(左上->右下), 提供一个offer, 每个格子都会考虑这个offer
- 如果offer更好，我们就会选择它，这个递推的方式可以理解沿着对角线(斜着(左下-右上)一条一条的划线，就像是BFS一样)
- 实际上更简单的方式是可以沿着矩阵的横线(或竖线)一行一行(一列一列)的来算，比如，我们一行一行的来算
- 比如进行到了d(i,j)的格子，它的offer来自三个方向(上方，左方，左上方)，即d(i-1,j-1),d(i-1,j),d(i,j-1)
- 当我们计算到d(i,j)的时候，为它提供offer的三个格子都已经计算就绪了，只需要进行对比，取最大值
- 如果最大值来自于左上角的一个格子，那么还需要加上一个1(这个方向是减而治之的情况，末字符匹配被减除，很好理解)
- 而其他两个方向的格子是分而治之得来的，对结果本身没有什么贡献，只是简单的继承过来
- 从这个意义上来说，我们计算最终的长度是几，就会有几次的减而治之，但是减而治之通常会有歧义，上面也说过
- 不过通过这种算法，我们都可以将所有可能覆盖，不会遗漏

### 0/1-Knapsack 背包问题

<div align="center">
    <img width="500" src="./screenshot/175.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 任何一个背包问题的输入都是由两列等长的数字组成，一个是v,一个是w
- 假设有一个场景，你出门旅行，带个背包，背包有个承受重量限度W，里面可以装很多东西
- 每一个物件都有一个重量，用w表示，同时这件东西对你的价值用v来表示
- 问题是，在给定的v和w两个序列，你有一个背包，最优(价值最大化)带走物品的方案是什么？
- 形式上来说:
    * $Given \{ v_i > 0 \ | \ 1 \leq i \leq n \}, \{ w_i > 0 \ | \ 1 \leq i \leq n \}$ and W > 0, find a subset K of [1,n] s.t.
    * $\sum_{k \in K} v_k \ is \ maximized \ while \sum_{k\in K} w_k \leq W$
- 我们拿到这个问题，可能会立即想到贪心的方法(实际上没法奏效)，举个例子，比如你有4件东西

<div align="center">
    <img width="500" src="./screenshot/176.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 它们的重量和价值都是一样的，四件的值分别是2，6，5，4，而背包容量是9，如何选择最优方案呢？
- 贪心无非两种方式：先贪最大的或先贪最小的
    * 如果先贪最大的，塞进去了6，那么5和4都不能放，只能选择2了
    * 从而装下的价值是6+2=8<9, 但是我们知道这个方法不是最优的
    * 因为我们明显能看到5+4=9，正好填满背包
    * 如果从小的开始贪，会碰到同样的甚至更尴尬的问题：2+4=6<9
    * 所以贪心策略并不合适
- 如何解决呢？我们还是需要一个递归的方法，回到之前的那张表上去，如上上图
- 每个格子都会在y轴对应一个最大值(该格子对应最上面一行数字中的一个数字)，代表了背包允许的最大值W
- 以该格子为起点, 在与y方向平行的v和w列中, 在y方向上会有以这个该格子所对应v,w为界的一个(v,w)前缀
- 这个格子所对应的子任务就是某一个重量的上限W, 在这个意义上来说，如果允许你装的物品不是所有的
- 而是其中前几项，此时所能得到的最大解(最优解)，就是我们装包的方案
- 这个方法最开始也是来自于递归，我们要把每个问题作为一个子问题来不断进行递归
- 如果上图比较抽象，可以将上面的表格简化为下面的矩阵

<div align="center">
    <img width="700" src="./screenshot/177.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 在这里$v_i, w_i$表示第i项的价值和重量，同理$v_{i-1}, w_{i-1}$是第i-1项的，此两项相邻
- 如上图所示，第i项中的一个格子表示：允许背包最大值是W，前i项最佳的装包方案是`m[i][W]`
- 这是一个二维矩阵，用二维数组来表示，下标分别为：W和i($v_i,w_i$)
- 按照刚才的语义，对于第i项的一个格子，可以分而治之，其实也就是考察它前面的两个问题($m[i-1][W-w_i], m[i-1][W]$)
- 这两个问题，都是对应于第i-1行的，第i-1行相对于第i行，区别就在于，第i项物品能不能装，答案有两种：选择第i项，不选择第i项
    * 如果没有考虑第i项，这种方案最优的在第i-1行来说对应的就是第i行正上方的$m[i-1][W]$
    * 正上方解的特点是它们位于同一列，背包所允许的容量没有变化都是W
    * 因为没有选择第i项，所以最优的解来自于同样背包容量下的第i-1项所得到的解(这个解暂时还没得到，但通过递归可以得到)
    * 如果考虑了第i项，那么现在把第i项减除(为了得到第i项的子任务，第i-1项的情况)，对应于只考虑前i-1项的问题
    * 这个问题对应就在第i-1行，而且它的列要从之前的W移动到W-$w_i$的位置，也就是$m[i-1][W-w_i]$这个格子
    * 总结来说，这个问题可以根据你在第i项出现之后所做的选择(选或不选)可以递归的分而治之为两个子问题
    * 这两个子问题如果可以递归得到，我们要做的时候就是在合并的时候把两者的最优解中的更大者保留下来即可

<div align="center">
    <img width="500" src="./screenshot/178.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 我们可以通过一个例子来说明，如上图，随便找一个格子，比如红框里的160作为第i行的一个最优解
- 它此时对于的W是21，而它对应物品(比如记该物品代号为p)的v,w分别是39,9
- 此时这个最终的160取决于两种情况, 选择了物品p，和不选择物品p
    * 如果选择了该物品p, 那么它的子任务就要从21-9=12，在第i-1行中的12对应的格子是121
    * 因为用了这个物品，所以这个121+39=160(我们的最大价值)，12+9=21(等于背包最大容量)
    * 另一种情况是不选择该物品p, 隐藏在160的正上方, 其值是149 < 160, 所以最终选择160，舍弃149
- 上图中每一个格子都是这样的例子，因为是递归的解法，它会向正上方和左上方减而治之，同样会造成指数爆炸
- 这时候我们就可以通过D.P.的逆向思维，从第一层算起，比如上图的第一项物品，其v,w是(42,4)，在背包允许容量达到4之前
- 它能装的东西为0(不能装任何东西), 当到达了4的重量，就可以装下第一项物品了
- 然后再往后不管W再怎么增大也只能装下这一件物品，因为当前只有这一件物品
- 有了这个基础的解之后，我们就可以算出第2行, 第3行, ... 
- 于是通过递推的方法把上表中所有的行每个单元的解一个不落地求出
- 如果我们指定任意一个W, 可以通过查阅该表中指定的W所对应的最后一行的那个格子就是能用所有物品情况下得到的最优解
- 这个填表的递推的方法，其实就是我们的动态规划，其实它的缺陷也很明显，时间复杂度太高了
- 如果我们有n件物品，背包最大限度是W, 那么意味着我们要把这个矩阵填完，其时间复杂度不会低于O(n * W)
- 在这里我们为了避免麻烦，把W取整处理，即便如此，我们的W是很难控制的，如果它很大，也会爆炸，虽然不是指数爆炸
- 虽然存在爆炸的可能，但是比之前递归减而治之的指数爆炸好太多了，我们要保证W不要太大
- 这个背包问题也可能有很多的变种，其基本套路都是基于这个0/1背包问题