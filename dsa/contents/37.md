动态规划 Dynamic Programming(DP)
---

### 引语

- 从上一篇文章中我们知道了为什么要做动态规划以及它是怎么一回事
- 动态规划基于原本递归的算法(效率低，会引起指数爆炸)，倒过来
- 递归是把原本复杂的事情变得简单，而动态规划是从最基础最简单的事情开始
- 从基础打起，一层一层很有耐心的把它算出来
- 也就是由几种子任务的递归结构转化成递推结构，换句话说
- 从递归的思路开始，不要扔掉它，它会给你一个解决方案(逻辑上的计算方式)
- 在真正实现的时候，把它倒过来计算，仅此而已

### LCS: Longest Common Subsequence 最长公共子序列

<div align="center">
    <img width="800" src="./screenshot/171.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 我们这里考虑的序列是字符串序列(string sequence)
- 某一天你可能会遇到两个string的问题, 每个string中元素都是有顺序的
- 如果你可以任意从中挑出几个字符排列起来，这样得到的序列就相对于之前序列叫做子序列
- 给你一对序列，从中分别抽出一些字符作为子序列，有时候非常的巧
- 挑出的两个子序列中含有相同的字符，我们称之为公共子序列, 显然这是取决于运气的
- 有的时候很容易得到，有的时候很难得到，有的时候完全没有公共子序列，我们要研究的是公共子序列的最长者
- 而有的时候最长的公共子序列可能包含多个，如上图的`DATA`和`DANA`，长度都是4
- 同时我们看到由顺序问题和多种选择引起的歧义，如上图下半部分的两图，所以我们先收敛一下
- 我们的问题主要是专注研究任何一对足够长的序列，在其中找出最长的子序列, 如何寻找呢？
- 我们倒过来看，我们有两个序列A和B, 不失一般性，A短，B长，无所谓的
- 它们末尾的末元素(字符)X，我们问一个问题，它俩是一样的么？答案肯定有两种：一样和不一样
- 如果一样，就在其前面切一刀，如下图所示，把它降解为更小的一个任务，前后任务长度差1
- 比如，我们要求`didacticA`和`advantA`的公共子串, 只需要再求`didactic`和`advant`的公共子串即可
- 这种情况，我们通过减而治之的方式来求解

<div align="center">
    <img width="600" src="./screenshot/172.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 如果不一样，也就是最后两个字符不同，这时候我们通过分而治之，把原来的任务分解为两个子任务

<div align="center">
    <img width="600" src="./screenshot/173.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 其中一个任务是，把一个字符串的末字符砍掉，另一个字符串的末字符保留
- 另一个任务是，把一个字符串的末字符保留，另一个字符串的末字符砍掉
- 如上图所示，把原先一个任务被分解为两个子任务了
- 这样的话最终的公共最长子串可以从这两个子任务中得到，只需要在二者之间取一个最大者即可
- 我们无非就是做上面的减而治之和分而治之来把最终的问题解决掉
- 从大体来看，我们可以把两个字符串通过坐标的形式来展示，坐标原点在左上角
- 如下图所示，有两个例子，任选其一即可

<div align="center">
    <img width="600" src="./screenshot/174.jpg">
    <br />
    <div style="text-align:center">备注：图片托管于github，请确保网络的可访问性</div>
    <br />
</div>

- 这么对齐来看的话，我们可以看到有一个矩阵，矩阵的每一个格子都对应一个子任务
- 一般而言，对于一个第i行，第j列的格子，用d(i,j)来表示，我们可以从坐标上得到两个新的字符串
- 横向的是0~j的字符串，纵向上是0~i的字符串，换句话说，我们只需要计算这两个新的字符串的LCS即可
- d(i,j)上LCS问题的解，从逻辑上来说就是这样的
- 如果我们要计算最左下角格子，也即是最终的任务(原始两字符串的LCS)
- 要考虑三种情况，一种是向上的，一种是向左的，一种是沿对角线方向(右下->左上)的递归
- 这些可能取决于A[n](A字符串的末字符)和B[m](B字符串的末字符)是否能够匹配
- 从递归上来说，会有子任务生成出来，会造成可怕的指数爆炸，这是逻辑上可行的
- 方法我们有了，我们要转过来，求助于递推，因为对于任何两个字符串，我们都会有递归基(递推基)
- 我们知道第一行都是0，从第二行开始才会有相应的值，我们可以用一种填表的方式来完成矩阵的填写
- 矩阵本身就是一个look-up table, 我们通过这些天然的递推基(字符串上的字符)
- 就可以给自己下面，右面，对角线(左上->右下), 提供一个offer, 每个格子都会考虑这个offer
- 如果offer更好，我们就会选择它，这个递推的方式可以理解沿着对角线(斜着(左下-右上)一条一条的划线，就像是BFS一样)
- 实际上更简单的方式是可以沿着矩阵的横线(或竖线)一行一行(一列一列)的来算，比如，我们一行一行的来算
- 比如进行到了d(i,j)的格子，它的offer来自三个方向(上方，左方，左上方)，即d(i-1,j-1),d(i-1,j),d(i,j-1)
- 当我们计算到d(i,j)的时候，为它提供offer的三个格子都已经计算就绪了，只需要进行对比，取最大值
- 如果最大值来自于左上角的一个格子，那么还需要加上一个1(这个方向是减而治之的情况，末字符匹配被减除，很好理解)
- 而其他两个方向的格子是分而治之得来的，对结果本身没有什么贡献，只是简单的继承过来
- 从这个意义上来说，我们计算最终的长度是几，就会有几次的减而治之，但是减而治之通常会有歧义，上面也说过
- 不过通过这种算法，我们都可以将所有可能覆盖，不会遗漏

