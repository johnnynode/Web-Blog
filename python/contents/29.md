### 测试对秩为1的ndarray进行排序

```python
import numpy as np

# 创建一个未排序的秩为1的ndarray
x = np.random.randint(1,11,size=(10,))

# 打印初始的x
print('初始的 x = ', x)

# 打印测试
print('排序后sort函数返回新的x: ', np.sort(x))
print('继续输出x，原x保持不变:', x)
```

输出：

```log
初始的 x =  [2 5 9 7 6 3 9 4 6 6]
排序后sort函数返回新的x:  [2 3 4 5 6 6 6 7 9 9]
继续输出x，原x保持不变: [2 5 9 7 6 3 9 4 6 6]
```

若被排序的 ndarray 具有重复的值，np.sort() 将在排好序的数组中保留这些值。但是，我们可以根据需要，同时使用 sort 函数和 unique 函数仅对 x 中的唯一元素进行排序, 如下：

```python
print(np.sort(np.unique(x)))
```

如果想要操作原来的ndarray对象, 直接排序，那么如下：

```python
import numpy as np
# 创建 秩为1的ndarray
x = np.random.randint(1,11,size=(10,))
# 输出：
print('初始的 x = ', x)
# 直接使用 ndarray的sort方法对x本身进行排序
x.sort()
# 打印可查看x本身的元素已经被修改了
print('被排序后的x:', x)
```

输出为：

```log
初始的 x =  [2 5 9 7 6 3 9 4 6 6]
排序后sort函数返回新的x:  [2 3 4 5 6 6 6 7 9 9]
继续输出x，原x保持不变: [2 5 9 7 6 3 9 4 6 6
```

### 测试对秩为2的ndarray进行排序

- 使用关键字axis，指定是按行排序，还是按列排序, axis 为 0 是对列排序，为1是对行排序

```python
import numpy as np
# 创建一个秩为2的未排序的ndarray
X = np.random.randint(1,19,size=(9,9))
# 打印 X
print('原始的 X = \n', X)
# 我们对X的列进行排序，并打印排序后的
print('对列排序后的X :\n', np.sort(X, axis = 0))
# 对X的行进行排序，并打印排序后的X
print('对行排序后的X :\n', np.sort(X, axis = 1))
```

输出：

```log
原始的 X = 
 [[10  2  2 13  7  8  4 13 13]
 [ 6 15 12  2  2 10  4 18 17]
 [ 1  9 18  3 17 10 16 11  4]
 [ 8  6 18 12 10  2 15  6 18]
 [ 2  1 13  8  8 18 18 12  6]
 [ 9  6  6 14  1 13  8  9 13]
 [10  9  6  4 10 10 18 11  1]
 [15  9 10 18  8 14  3 10  6]
 [18 18  8  5  9  7 16 14  4]]
对列排序后的X :
 [[ 1  1  2  2  1  2  3  6  1]
 [ 2  2  6  3  2  7  4  9  4]
 [ 6  6  6  4  7  8  4 10  4]
 [ 8  6  8  5  8 10  8 11  6]
 [ 9  9 10  8  8 10 15 11  6]
 [10  9 12 12  9 10 16 12 13]
 [10  9 13 13 10 13 16 13 13]
 [15 15 18 14 10 14 18 14 17]
 [18 18 18 18 17 18 18 18 18]]
对行排序后的X :
 [[ 2  2  4  7  8 10 13 13 13]
 [ 2  2  4  6 10 12 15 17 18]
 [ 1  3  4  9 10 11 16 17 18]
 [ 2  6  6  8 10 12 15 18 18]
 [ 1  2  6  8  8 12 13 18 18]
 [ 1  6  6  8  9  9 13 13 14]
 [ 1  4  6  9 10 10 10 11 18]
 [ 3  6  8  9 10 10 14 15 18]
 [ 4  5  7  8  9 14 16 18 18]]
```