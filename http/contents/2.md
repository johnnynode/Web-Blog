### 关于网络协议分层

- 熟悉网络协议分层模型可以更好的理解HTTP协议
- 网络协议有一个经典的五层模型，从低级到高级如下
    * 物理层
    * 数据链路层
    * 网络层
    * 传输层
      * eg: TCP, UDP
    * 应用层
      * eg: HTTP, FTP
- 不管是客户端还是服务器都遵循这个模型以此来维护网络传输过程的
- 我们的HTTP协议是在应用层上实现的，但它要基于传输层中非常重要的一个协议：TCP/IP协议
- TCP/IP协议是网络模型中最重要的一个协议，在应用中比如创建一个HTTP服务,FTP服务,Email服务
- 这些服务都是基于TCP/IP协议实现的，HTTP请求的性能以及过程的消耗都会涉及到TCP/IP协议
- 物理层主要是定义物理设备如何传输数据
    * 物理层是硬件设备：计算机硬件：网卡端口, 网线, 光缆等
    * 没有物理层，我们的软件是无法去使用的
- 数据链路层是在通信的实体间建立数据链路连接
    * 两台机器物理上是可以连接在一起的，同时需要一个软件服务通过物理设备实现电路的连接
    * 使得两台机器可以传输数据，这些数据都是0101...这类东西
- 网络层是为数据在节点之间传输创建逻辑链路
    * 比如，从我的电脑访问远程服务器，我们如何去寻找服务器所在地址就是一个逻辑关系
    * 这个关系是在网络层为我们创建的
- 物理层，数据链路层，网络层这三层比较底层，和我们的HTTP关系不是很大
- 传输层，主要有两个协议：TCP/IP协议, UDP协议
    * 更多时候使用的是TCP/IP协议，更可靠
    * 传输层为用户提供可靠的端到端服务
    * 比如：建立了从我的电脑到远程服务器之间的连接后，两端传输数据的方式在这一层被定义
    * 传输的数据有可能很小也可能很大, 如果数据很大就会被分包和分片，分片传输之后的数据会被重新组装
    * 协议的定义，如何传输，如何去组装等等都是在传输层被定义的
    * 传输层向高层屏蔽了下层数据通信的细节，HTTP协议的实现是在TCP/IP协议基础之上的
    * 一次HTTP的数据传输涉及到一系列的数据的拼装和传输，这个过程细节我们不需要知道
    * 因为怎样分片和传输都是被传输层封装好的
- 应用层，最主要是就是HTTP协议，主要是为应用软件提供了很多服务
    * 比如，我们发送一个HTTP请求，只需要new一个request即可发送数据，非常方便
    * 应用层帮我们实现了HTTP协议，我们只要使用http协议相关工具即可
    * HTTP协议是构建于TCP/IP协议之上的，传输的细节都在TCP/IP协议上面，因此屏蔽了网络传输相关细节

### HTTP协议的发展历史

- 最早定稿的协议是：HTTP/0.9
    * 在这个版本里，HTTP协议的内容非常简单，只有一个GET命令(或方法)
    * 没有HEADER等描述数据的信息
    * 服务器发送完毕，就关闭TCP连接
      * 注意这里HTTP请求和TCP连接不是一个概念
      * 一个TCP连接里可以发送很多HTTP请求(该版本不能实现，但在HTTP1.1中可以实现, HTTP2中做了更多优化)
- 第二个版本是：HTTP/1.0
    * 这个版本和目前普遍使用的1.1版本差不了多少
    * 这个版本中增加了很多命令：POST,PUT,HEAD等
    * 也增加了status code和header相关内容
      * status code中定义了很多状态码,描述服务端处理请求后的状态
      * header描述了发送或请求的相关数据描述以及对这部分数据如何操作的方法
    * 增加了多字符集的支持,多部分发送,权限,缓存等
- 第三个版本是：HTTP/1.1
    * 在1.0版本上增加了一些功能来优化网络连接的过程
    * 支持持久连接
      * 在1.0版本，一个HTTP请求,就要在客户端和服务端之间创建一个TCP连接
      * 创建链接，服务端响应之后，这个TCP连接就关闭了，这个成本是比较高的
      * 因为在建立一个HTTP连接过程中要进行HTTP的三次握手，这一部分在TCP协议中被封装
      * 这个过程消耗是比较高, 延迟也会比较高, 所以是有待优化的
      * 所以在1.1版本中，建立一个TCP连接后可以不关闭，新的HTTP请求一直在这个连接中发送
      * 这样的话将极大提高了性能
    * 增加了pipeline
      * 在同一个TCP连接中可以发送多个请求之后，但是在服务端接收的请求在响应时要按顺序响应
      * 如果前一个请求等待时间较长，后一个请求处理较快，这时候后一个请求不能先发送
      * 需要等第一个请求数据全部响应完成后，才轮到第二个，这里面的时间也就是串行和并行的性能差异
      * 这个在HTTP2中进行过了优化
    * 增加host和其他一些命令
      * 有了host之后就可以在同一台服务器跑多个不同的web服务
      * 通过host字段表示都是请求在这一台物理服务器上面，但是可以是不同的软件服务
      * 好处是在同一个物理服务器或集群中可以部署很多不同的web服务来进行使用，提高物理服务使用效率
- 最新版本：HTTP2
    * 在2版本中所有数据以二进制传输, 在1.1版本中大部分数据是字符串
    * 因此，数据的分片方式会有不同，在2中所有数据以帧进行传输，因此同一个连接里发送多个请求不再需要按顺序来返回处理，这样通过并行的方式，能够更大限度的让整个web应用提高效率
    * 增加头信息压缩以及推送等提高效率的功能
      * 在1.1版本中每一次发送请求和返回请求, HTTP头要进行完整的发送和返回，这里的头信息以字符串保存，所以它占用字节带宽会很大
      * 在2版本中，头信息进行了压缩，有效减少带宽使用
      * 关于推送功能，以前版本只能一个发送，一个接受，客户端永远是主动方，服务端永远是被动方
      * 在2版本中新增的推送功能让服务端主动发起数据传输，举个例子，web页面中很多资源如脚本和图片
      * 在之前版本需要先解析html文本，在浏览器中运行解析后，再去发送这些资源的请求
      * 在2版本中，在请求html文本的同时，服务器可以主动推送这些资源到客户端
      * 这样的话html文本和其他资源的发送以并行的方式来运作，整体传输效率要大大提高
- 特殊版本：HTTPS
    * 是一个安全版本的HTTP协议, 实际使用内容和1.1版本没有太大区别
    * 在此先不讨论